==JSON-RPC==

JSON-RPC in a remote object protocol based on the JavaScript Object Notation (JSON). In this protocol, method invocations performed on client side JavaScript objects are transmitted to the server in JSON format. From there, a server side service invoker is responsible for controlling access rights and performing the method invocations on the actual server based objects. The result is then converted to JSON, transmitted back to the client and desterilized into a JavaScript object.

The advantage of using this protocol with UIDL is that it is extremely flexible: no Java class libraries need to be transmitted to the client to support the corresponding implementations which reside on the server (as would be needed with alternative protocols such as RMI). This allows client memory footprints to remain small and allows UIDL scripts to be relatively robust to changes in server side objects (code will only break if method signatures change dramatically).

To use JSON RPC, the server must be modified to expose any objects which must be accessible by the client. This can be done inside a simple servlet or (better still) a servlet listener. The code to register an object should be similar to the following:

{{{
Hello hello = new Hello();
JSONRPCBridge.getGlobalBridge().registerObject("hello", hello);
}}}

This will make the "Hello" object accessible from UIDL clients using the JSON RPC protocol.

*Alternatively, the JsonRpcExporter service can be used to register Spring hosted objects.* This is the technique employed by the bundled example applications.

In order to access the object from a UIDL script, the following code can be used:

{{{
jsonrpc = new JSONRpcClient(hostPrefix + "JSON-RPC");
message = jsonrpc.hello.sayHello("Dominic");
}}}

For requests which might take some time, a callback can be used which will be called with the return parameter once the method invocation is complete. In this case, the code would look similar to the following:

{{{
function callback(result, exception)
{
    System.out.println(result);
}

jsonrpc = new JSONRpcClient(hostPrefix + "JSON-RPC");
jsonrpc.hello.sayHello(callback, "Dominic");
}}}

The JSON RPC protocol does have some disadvantages in that it is less efficient for requests which return large amounts of data (such as collections of objects) due to the expense of converting Java objects to JavaScript notation. In addition, complex objects which are returned via the JSONRpcCilent are not directly usable in UIDL scripts. They can be passed back to the server and referenced, although their internal properties remain opaque.

To address this last concern and to increase the performance somewhat, a native Java implementation of the JSON RPC client can be used (the afore mentioned JSONRpcCilent is implemented in JavaScript). The configuration for this second approach is identical on the server, although the client code should be implemented as follows:

{{{
// Libraries for json-rpc-client
browser.loadRemoteLibrary("../jar/remoteClasses.jar");
browser.loadRemoteLibrary("../jar/json-rpc-client.jar");
browser.loadRemoteLibrary("../jar/httpclient.jar");
browser.loadRemoteLibrary("../jar/json.jar");
browser.loadRemoteLibrary("../jar/jsonrpc.jar");
browser.loadRemoteLibrary("../jar/commons-codec.jar");
browser.loadRemoteLibrary("../jar/commons-logging.jar");

browser.include("packages.uidl");

var hostRoot = "http://" + hostName + ":" + hostPort + "/uidl/";
Client = Packages.org.apache.commons.httpclient;
JsonRpc = Packages.org.codebistro.jsonrpc;
JsonRpc.HTTPSession.register(JsonRpc.TransportRegistry.i());
var httpSession= JsonRpc.TransportRegistry.i().createSession(hostRoot + "JSON-RPC");
var state = new Client.HttpState();
httpSession.setState(state);
client = new JsonRpc.Client(httpSession);
}}}

Basically, the UIDL browser will require the help of several external Java libraries to make use of the JSON-RPC Java client. Once we have constructed a "client" object, it is trivial to make calls to any services exposed on the server:

{{{
var userManager = client.openProxy("userManager", Uidl.example.UserManager);
var users = userManager.getUsers();
...
}}}

The disadvantage of this approach (over the native JavaScript variant) is that the UIDL browser must have access to the class files representing the server side interfaces (e.g. UserManaer) and for any serialized objects (e.g. User). This requires more coordination as we need to ensure that whenever these files are modified on the server, we make the corresponding remote interfaces (a sub-set of the server files) available to the client. See the remoteClassJar target in the build section for one way of doing this efficiently.